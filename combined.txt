<code_file>
### File: ./.env

DB_NAME=myprojectdb
DB_USER=derek
DB_PASSWORD=postgres
DB_HOST=db
DB_PORT=5432

POSTGRES_DB=myprojectdb
POSTGRES_USER=derek
POSTGRES_PASSWORD=postgres

ALLOWED_HOSTS=test-server-0.click
</code_file>

<code_file>
### File: ./default.conf

# Redirect HTTP traffic to HTTPS for both the main domain and the API subdomain
server {
    listen 80;
    server_name test-server-0.click api.test-server-0.click;
    
    location /.well-known/acme-challenge/ {
        root /usr/share/nginx/html;
        try_files $uri $uri/ =404;
    }
    location / {
        return 301 https://$host$request_uri;
    }
}

# Configuration for the main domain
server {
    listen 443 ssl;
    server_name test-server-0.click;

    ssl_certificate /etc/letsencrypt/live/test-server-0.click/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/test-server-0.click/privkey.pem;

    # Redirect API requests to the API subdomain
    location ~ ^/api/ {
        rewrite ^/api/(.*)$ https://api.test-server-0.click/$1 permanent;
        internal;
    }

    location / {
        root /usr/share/nginx/html;
        index index.html index.html;
        try_files $uri $uri/ =404;
    }
    
    location = /zbHealthCheck {
    access_log off;
    return 200 'healthy';
    add_header Content-Type text/plain;
}

}

# Configuration for the API subdomain
server {
    listen 443 ssl;
    server_name api.test-server-0.click;
    try_files $uri $uri/ =404;

    ssl_certificate /etc/letsencrypt/live/test-server-0.click/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/test-server-0.click/privkey.pem;

    # SSL parameters directly included
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 5m;
    ssl_ciphers 'EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH';
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_stapling on;
    ssl_stapling_verify on;

    # Handle API requests
    location / {
        proxy_pass http://backend:8000;
        proxy_http_version 1.1;
        proxy_set_header Host $http_host;
        proxy_set_header X-CSRFTOKEN $http_x_csrftoken;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $server_name;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_redirect off;
        proxy_cookie_path / "/; HTTPOnly; Secure";
    }
}
</code_file>

<code_file>
### File: ./docker-compose.dev.yml

services:
  db:
    image: postgres:latest
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      POSTGRES_DB: myprojectdb
      POSTGRES_USER: derek
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    command: bash -c "gunicorn wsgi:application --bind 0.0.0.0:8000"
    ports:
      - "8000:8000"
    env_file:
      - .env
    depends_on:
      - db

  frontend:
    image: nginx:latest
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./default.conf:/etc/nginx/conf.d/default.conf:ro  #  Nginx configuration file location
      - /etc/letsencrypt:/etc/letsencrypt:ro  # Path for accessing Let's Encrypt SSL Certs for HTTPS
      - /etc/nginx/ssl:/etc/nginx/ssl:ro  # Path to Diffie-Hellman Key Exchange Enc.
      - ./frontend/dist:/usr/share/nginx/html  # Frontend file location to serve with NGINX
    depends_on:
      - backend

volumes:
  postgres_data:
</code_file>

<code_file>
### File: ./docker-compose.yml

version: '3.8'

services:
  frontend:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "80:80"
    depends_on:
      - backend

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    command: gunicorn wsgi:application --bind 0.0.0.0:8000
    ports:
      - "8000:8000"
    env_file:
      - .env
</code_file>

<code_file>
### File: ./Dockerfile

# encrypted-file-transfer/Dockerfile
# Dockerfile for NGINX, which is a web server
# that will serve the built React frontend of the application.

FROM nginx
COPY ./frontend/dist /usr/share/nginx/html
COPY default.conf /etc/nginx/conf.d/default.conf
</code_file>

<code_file>
### File: ./.vscode/settings.json

{
    "git.ignoreLimitWarning": true,
    "liveServer.settings.port": 5501
}
</code_file>

<code_file>
### File: ./backend/apps.py

from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "core"

</code_file>

<code_file>
### File: ./backend/asgi.py

"""
ASGI config for backend project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings")

application = get_asgi_application()

</code_file>

<code_file>
### File: ./backend/Dockerfile

# encrypted-file-transfer/backend/Dockerfile

FROM python:3.9-slim

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

# Set work directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && \
    apt-get install -y bash && \
    apt-get install -y netcat-openbsd && \
    apt-get clean

# Install dependencies
COPY requirements.txt /app/requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# Copy project
COPY . /app/

# Collect static files
RUN python manage.py collectstatic --no-input

EXPOSE 8000

</code_file>

<code_file>
### File: ./backend/manage.py

#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()

</code_file>

<code_file>
### File: ./backend/settings.py

# encrypted-file-transfer/backend/settings.py
"""
Django settings for backend project.

Generated by 'django-admin startproject' using Django 5.0.2.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

from pathlib import Path
from datetime import timedelta
import os
import logging

# Assuming all backend Django files are in /app
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.environ.get('SECRET_KEY', 'django-insecure-d(7j9=&*)w%-m4bj!u9x3f68!zp58)px16+du#6a(r^!3(#h_e')
# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True
CORS_ALLOW_CREDENTIALS = True

ALLOWED_HOSTS = [os.environ.get('ALLOWED_HOSTS', 'localhost'), '0.0.0.0', 'test-server-0.click', 'api.test-server-0.click',]

CSRF_TRUSTED_ORIGINS = [
    # environment variable for the frontend URL
    os.environ.get('FRONTEND_URL', f'http://localhost:{os.environ.get("FRONTEND_PORT", "3000")}'),
    'https://test-server-0.click', 'http://test-server-0.click', 'http://localhost:80', 'https://localhost:80',
    'https://localhost:3000', 
]

CORS_ORIGIN_WHITELIST = [
    'https://localhost:3000',
    'http://localhost:3000',
    'https://localhost:80',
    'http://localhost:80',
    'https://test-server-0.click',
    'http://test-server-0.click',
]

# What's the difference between CSRF_TRUSTED_ORIGINS and CORS_ALLOWED_ORIGINS?
# CSRF_TRUSTED_ORIGINS is used to specify which origins are allowed to send
# cross-site requests. This is important for security reasons, as it helps
# prevent cross-site request forgery (CSRF) attacks. If you're using Django's
# CSRF protection middleware, you'll need to specify the origins that are
# allowed to send requests to your site. This is done by setting the
# CSRF_TRUSTED_ORIGINS setting in your Django settings file.
#
# CORS_ALLOWED_ORIGINS, on the other hand, is used to specify which origins
# are allowed to make cross-origin requests to your site. This is important
# for allowing requests from different domains, such as when you're building
# a frontend application that needs to make requests to a backend API. If you're
# using Django's CORS middleware, you'll need to specify the origins that are
# allowed to make requests to your site. This is done by setting the
# CORS_ALLOWED_ORIGINS setting in your Django settings file.
CORS_ALLOWED_ORIGINS = [
    os.environ.get('FRONTEND_URL', f'http://localhost:{os.environ.get("FRONTEND_PORT", "3000")}'),
    'http://test-server-0.click', 'https://test-server-0.click', 'https://test-server-0.click:80'
]

SESSION_COOKIE_AGE = 60

CSRF_COOKIE_HTTPONLY = True

SESSION_COOKIE_SECURE = True
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = 'Lax'

CSRF_COOKIE_SECURE = True
CSRF_COOKIE_SAMESITE = 'Lax'
SESSION_COOKIE_SAMESITE = 'None'


# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "core",
    "corsheaders",
    'debug_toolbar',
    'rest_framework',
    'knox',
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "debug_toolbar.middleware.DebugToolbarMiddleware",
    "core.middleware.RequestLoggingMiddleware",
]

DEBUG_TOOLBAR_PANELS = [
    'debug_toolbar.panels.headers.HeadersPanel',
    'debug_toolbar.panels.request.RequestPanel',
]

SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'knox.auth.TokenAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    )
}

ROOT_URLCONF = "urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "wsgi.application"


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

# Test Db:
# DATABASES = {
#     'default': {
#         'ENGINE': 'django.db.backends.postgresql',
#         'NAME': 'myprojectdb',
#         'USER': 'derek',
#         'PASSWORD': 'postgres',
#         'HOST': 'db',
#         'PORT': '5432',
#     }
# }

# Production DB:
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": os.environ.get('DB_NAME', 'myprojectdb'),  # Default value is 'myproject-db'
        "USER": os.environ.get('DB_USER', 'derek'),  # Default value is 'postgres'
        "PASSWORD": os.environ.get('DB_PASSWORD', 'postgres'), 
        "HOST": os.environ.get('DB_HOST', 'localhost'),
        "PORT": os.environ.get('DB_PORT', '5432'),  # Default value is '5432'
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]

INTERNAL_IPS = [
    '127.0.0.1',
]

# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True

# Static URL is only used for development and not for
# production, ie serving our React app using Nginx.
STATIC_URL = '/static/'

# Directory where Django will store collected static files
# Adjust if necessary to match your desired path for static files

# REACT_APP_DIR isn't needed since we're serving our React app using Nginx.
# REACT_APP_DIR is a variable that points to the build directory
# of our React app. It's used in cases whenever you'd want your
# backend to serve the frontend as well. In this case, we're
# offloading this responsibility to Nginx, and using Django
# solely for backend functionality.
# REACT_APP_DIR = os.path.join(BASE_DIR, 'frontend/build')

# Directory where Django will store collected static files.
# This application doesn't store static files, as they are
# passed from the front end to the backend as blobs. A blob is
# essentially binary data that is only temporarily stored in memory
# for encrypting and decrypting, and is not stored on the server.
# It was only added here because Django gets angry if it's not there.
STATIC_ROOT = os.path.join(BASE_DIR, 'static')
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

# Default primary key field type
DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"


# Logging added for spotting AWS RDS connection issues and other
# potential problems during the deployment process.
LOGGING = {
    'version': 1,
    'handlers': {
        'console': { 
            'level': 'DEBUG',
            'class': 'logging.StreamHandler', 
        },
    },
    'loggers': {
        'django': { 
            'handlers': ['console'], 
            'level': 'DEBUG',
            'propagate': True, 
        },
    },
}
</code_file>

<code_file>
### File: ./backend/urls.py

# encrypted-file-transfer/backend/urls.py

from django.urls import path, include
from views import index  # Adjusted import depending on your project structure

urlpatterns = [
    path('api/', include('core.urls')),
]

</code_file>

<code_file>
### File: ./backend/views.py

# encrypted-file-transfer/backend/views.py

from django.shortcuts import render
from django.http import HttpResponse
from django.conf import settings
import os
from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse

@csrf_exempt
def index(request):
  try:
    with open(os.path.join(settings.REACT_APP_DIR, 'index.html')) as f:
      return HttpResponse(f.read())
  except FileNotFoundError:
    return HttpResponse(
      """
      This URL is only accessible after you've built the React frontend.
      """,
      status=501,
    )

</code_file>

<code_file>
### File: ./backend/wsgi.py

print("WSGI file loaded")
"""
WSGI config for project.

It exposes the WSGI callable as a module-level variable named ``application``.
"""

import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')

application = get_wsgi_application()
</code_file>

<code_file>
### File: ./backend/__init__.py


</code_file>

<code_file>
### File: ./backend/core/.~c9_invoke_GU1igA.py

# backend/core/views.py

from django.http import JsonResponse, HttpResponse
import boto3
from django.contrib.auth.models import User
from django.contrib.auth import authenticate, login, logout
from django.views.decorators.csrf import csrf_exempt, ensure_csrf_cookie
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework import status
from django.contrib.auth.decorators import login_required
from rest_framework.permissions import AllowAny, IsAuthenticated

from .crypto_utils import encrypt_aes, decrypt_aes, generate_key_iv
from .models import EncryptedFile
import uuid
import base64
import logging

logger = logging.getLogger(__name__)

# @csrf_exempt
# @api_view(['GET'])
# def test_endpoint(request):
#     return JsonResponse({"message": "Test endpoint working!"})

# @csrf_exempt
# @api_view(['GET'])
# def generate_username(request):
#     logger.info("Frontend has requested the generated username.")
#     return JsonResponse({'username': 'Derek Gary'})

# @api_view(['POST'])
# @permission_classes([AllowAny])
# def register(request):
#     username = request.data.get('username')
#     password = request.data.get('password')
#     email = request.data.get('email')
    
#     if User.objects.filter(username=username).exists():
#         return Response({"error": "Username already taken"}, status=status.HTTP_409_CONFLICT)
#     if User.objects.filter(email=email).exists():
#         return Response({"error": "Email already in use"}, status=status.HTTP_409_CONFLICT)

#     user = User.objects.create_user(username=username, email=email, password=password)
#     login(request, user)  # Log the user in, Django handles cookie setting
#     return JsonResponse({"detail": "User registered successfully"})

# @api_view(['POST'])
# def logout_view(request):
#     logout(request)  # Django clears the session
#     response = JsonResponse({"detail": "Logged out"})
#     response.delete_cookie('sessionid')  # Ensure to delete the sessionid cookie
#     return response

# @api_view(['POST'])
# @permission_classes([AllowAny])
# def login_view(request):
#     username = request.data.get('username')
#     password = request.data.get('password')
#     user = authenticate(request, username=username, password=password)
#     if user is not None:
#         login(request, user)  # Log the user in, Django handles cookie setting
#         return JsonResponse({'detail': 'Login successful'})
#     else:
#         return JsonResponse({'error': 'Invalid username or password'}, status=401)



@api_view(['POST'])
def file_process(request):
    if request.method == 'POST' and request.FILES:
        file = request.FILES['file']
        action = request.POST.get('action', '')
        logger.info(f"Received file for action {action}.")
        return JsonResponse({'message': 'File processed successfully'})
    return JsonResponse({'error': 'Invalid request'}, status=400)




@csrf_exempt
@api_view(['GET'])
def test_s3_connection(request):
    """
    Test connectivity to AWS S3 by listing the buckets available.
    """
    s3_client = boto3.client('s3')
    try:
        # Attempt to list buckets
        response = s3_client.list_buckets()
        
        # Extract bucket names to demonstrate connectivity
        buckets = [bucket['Name'] for bucket in response['Buckets']]
        return JsonResponse({'message': 'Successfully connected to S3.', 'buckets': buckets})
        
        # Log Error Messagge to Docker Logs in case of failure.
    except Exception as e:
        logger.error(f"\n\n\n == S3 BUCKET ERROR == \n\n\nFailed to connect to S3: {str(e)}\n\n\n")
        return JsonResponse({'error': f"Failed to connect to S3: {str(e)}"}, status=500)



@api_view(['GET'])
@permission_classes([AllowAny])
def test_headers(request):
    """
    Return the headers received from the request.
    """
    headers = dict(request.headers)
    return JsonResponse({'received_headers': headers})
    
    
    
@api_view(['POST'])
@ensure_csrf_cookie
@permission_classes([AllowAny])
def test_csrf_and_headers(request):
    """
    Return the headers received and compare them to expected CSRF tokens.
    """
    received_headers = dict(request.headers)
    expected_token = request.META.get('CSRF_COOKIE', 'No CSRF cookie found')
    return JsonResponse({
        'received_headers': received_headers,
        'expected_csrf_token': expected_token
    })

</code_file>

<code_file>
### File: ./backend/core/admin.py

from django.contrib import admin

# Register your models here.

</code_file>

<code_file>
### File: ./backend/core/apps.py

from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "core"

</code_file>

<code_file>
### File: ./backend/core/middleware.py

import logging
logger = logging.getLogger(__name__)

class RequestLoggingMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)
        logger.debug(f"Request Headers: {request.headers}")
        logger.debug(f"Request Cookies: {request.COOKIES}")
        logger.debug(f"Request Path: {request.path}")
        return response
</code_file>

<code_file>
### File: ./backend/core/models.py

# encrypted-file-transfer/backend/core/models.py

from django.db import models
from django.utils import timezone
import datetime
from uuid import uuid4
        
class SecureFileUpload(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4, editable=False)
    sub_id = models.CharField(max_length=32, unique=True)
    file_size = models.BigIntegerField(default=0)
    created_at = models.DateTimeField(default=timezone.now)
    file_metadata = models.JSONField(null=True, blank=True)
    
    def __str__(self):
        return str(self.id)
</code_file>

<code_file>
### File: ./backend/core/tests.py

from django.test import TestCase

# Create your tests here.

</code_file>

<code_file>
### File: ./backend/core/urls.py

# encrypted-file-transfer/backend/core/urls.py

from django.urls import path
from . import views

urlpatterns = [
    # path('test/', views.test_endpoint, name='test_endpoint'),
    # path('generate_username/', views.generate_username, name='generate_username'),
    # path('register/', views.register, name='register'),
    # path('login/', views.login_view, name='login_view'),
    # path('logout/', views.logout_view, name='logout_view'),
    path('file_process/', views.file_process, name='file_process'),
    path('test_s3/', views.test_s3_connection, name='test_s3_connection'),
    path('test_headers/', views.test_headers, name='test_headers'),
    path('test_csrf_and_headers/', views.test_csrf_and_headers, name='test_csrf_and_headers'),
    path('file_limits/', views.file_limits, name='file_limits'),
    path('<uuid:id>/<str:sub_id>/upload-complete/', views.file_upload_complete, name='file_upload_complete'),
    ]
</code_file>

<code_file>
### File: ./backend/core/views.py

# backend/core/views.py

import boto3
from django.http import JsonResponse, HttpResponse
from django.contrib.auth.models import User
from django.contrib.auth import authenticate, login, logout
from django.views.decorators.csrf import csrf_exempt, ensure_csrf_cookie
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework import status
from django.contrib.auth.decorators import login_required
from rest_framework.permissions import AllowAny, IsAuthenticated

from .crypto_utils import encrypt_aes, decrypt_aes, generate_key_iv
from .models import SecureFileUpload
import uuid
import base64
import logging
import random
import string
from django.utils import timezone
import datetime

logger = logging.getLogger(__name__)

# @csrf_exempt
# @api_view(['GET'])
# def test_endpoint(request):
#     return JsonResponse({"message": "Test endpoint working!"})

# @csrf_exempt
# @api_view(['GET'])
# def generate_username(request):
#     logger.info("Frontend has requested the generated username.")
#     return JsonResponse({'username': 'Derek Gary'})

# @api_view(['POST'])
# @permission_classes([AllowAny])
# def register(request):
#     username = request.data.get('username')
#     password = request.data.get('password')
#     email = request.data.get('email')
    
#     if User.objects.filter(username=username).exists():
#         return Response({"error": "Username already taken"}, status=status.HTTP_409_CONFLICT)
#     if User.objects.filter(email=email).exists():
#         return Response({"error": "Email already in use"}, status=status.HTTP_409_CONFLICT)

#     user = User.objects.create_user(username=username, email=email, password=password)
#     login(request, user)  # Log the user in, Django handles cookie setting
#     return JsonResponse({"detail": "User registered successfully"})

# @api_view(['POST'])
# def logout_view(request):
#     logout(request)  # Django clears the session
#     response = JsonResponse({"detail": "Logged out"})
#     response.delete_cookie('sessionid')  # Ensure to delete the sessionid cookie
#     return response

# @api_view(['POST'])
# @permission_classes([AllowAny])
# def login_view(request):
#     username = request.data.get('username')
#     password = request.data.get('password')
#     user = authenticate(request, username=username, password=password)
#     if user is not None:
#         login(request, user)  # Log the user in, Django handles cookie setting
#         return JsonResponse({'detail': 'Login successful'})
#     else:
#         return JsonResponse({'error': 'Invalid username or password'}, status=401)



@api_view(['POST'])
@ensure_csrf_cookie
@permission_classes([AllowAny])
def file_process(request):
    if request.method == 'POST':
        # Generate a random 24-digit ID
        main_id = ''.join(random.choices(string.ascii_letters + string.digits, k=24))
        
        # Generate a separate 32-digit SubID
        sub_id = ''.join(random.choices(string.ascii_letters + string.digits, k=32))
        
        # Initialize a filesize of 0
        file_size = 0
        
        # Chart the time file was received
        created_at=timezone.now().isoformat()
        
        # Create a new SecureFileUpload instance and store it in the database
        secure_file_upload = SecureFileUpload.objects.create(
            main_id,
            sub_id,
            file_size,
            created_at
        )
        
        # Return the necessary information to the frontend
        response_data = {
            'created': secure_file_upload.created_at,
            'fileSize': secure_file_upload.file_size,
            'files': [],
            'id': secure_file_upload.main_id,
            'subId': secure_file_upload.sub_id
        }
        
        return Response(response_data, status=status.HTTP_200_OK)
    
    return Response({'error': 'Invalid request'}, status=status.HTTP_400_BAD_REQUEST)

@api_view(['GET'])
@ensure_csrf_cookie
@permission_classes([AllowAny])
def file_limits(request):
    """
    Grab allowed max file size, the number of files one can upload,
    and expiration time as a JSON object.
    """
    data = {
        'expiresInMinutes': 1440,
        'fileNumber': 1,
        'totalFileSizeMb': 5,
    }
    try:
        response = data
        return JsonResponse(data)
    
    except Exception as e:
        logger.error(f"\n\n\n == FILE METADATA ERROR ==\n\n\nFailed to send file limits to frontend: {str(e)}\n\n\n")
        return JsonResponse({'error': f"Failed to send file limits to frontend: {str(e)}"}, status=500)
    
@api_view(['GET'])
@permission_classes([AllowAny])
def test_s3_connection(request):
    """
    Test connectivity to AWS S3 by listing the buckets available.
    """
    s3_client = boto3.client('s3')
    try:
        # Attempt to list buckets
        response = s3_client.list_buckets()
        
        # Extract bucket names to demonstrate connectivity
        buckets = [bucket['Name'] for bucket in response['Buckets']]
        return JsonResponse({'message': 'Successfully connected to S3.', 'buckets': buckets})
        
        # Log Error Messagge to Docker Logs in case of failure.
    except Exception as e:
        logger.error(f"\n\n\n == S3 BUCKET ERROR == \n\n\nFailed to connect to S3: {str(e)}\n\n\n")
        return JsonResponse({'error': f"Failed to connect to S3: {str(e)}"}, status=500)



@api_view(['GET'])
def test_headers(request):
    """
    Return the headers received from the request.
    """
    headers = dict(request.headers)
    return JsonResponse({'received_headers': headers})
    
    
    
@api_view(['POST'])
@ensure_csrf_cookie
def test_csrf_and_headers(request):
    """
    Return the headers received and compare them to expected CSRF tokens.
    """
    received_headers = dict(request.headers)
    expected_token = request.META.get('CSRF_COOKIE', 'No CSRF cookie found')
    return JsonResponse({
        'received_headers': received_headers,
        'expected_csrf_token': expected_token
    })

</code_file>

<code_file>
### File: ./backend/core/__init__.py


</code_file>

<code_file>
### File: ./backend/core/migrations/0001_initial.py

# Generated by Django 5.0.3 on 2024-03-10 03:53

import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='EncryptedFile',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('uuid', models.UUIDField(default=uuid.uuid4, editable=False)),
                ('key', models.BinaryField()),
                ('iv', models.BinaryField()),
            ],
        ),
    ]

</code_file>

<code_file>
### File: ./backend/core/migrations/__init__.py


</code_file>

<code_file>
### File: ./frontend/.eslintrc.cjs

module.exports = {
  root: true,
  env: { browser: true, es2020: true },
  extends: [
    'eslint:recommended',
    'plugin:react/recommended',
    'plugin:react/jsx-runtime',
    'plugin:react-hooks/recommended',
  ],
  ignorePatterns: ['dist', '.eslintrc.cjs'],
  parserOptions: { ecmaVersion: 'latest', sourceType: 'module' },
  settings: { react: { version: '18.2' } },
  plugins: ['react-refresh'],
  rules: {
    'react/jsx-no-target-blank': 'off',
    'react-refresh/only-export-components': [
      'warn',
      { allowConstantExport: true },
    ],
  },
}

</code_file>

<code_file>
### File: ./frontend/index.html

<!-- frontend/index.htm -->
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/svg+xml" href="/vite.svg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#000000">
    <link rel="apple-touch-icon" href="/logo192.png">
    <link rel="manifest" href="/manifest.json">
    <!-- Bootstrap CSS CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <title>Encrypted File Transfer</title>
</head>
<body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!-- Bootstrap Bundle with Popper.js -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
    <script type="module" src="/src/main.jsx"></script>
</body>
</html>

</code_file>

<code_file>
### File: ./frontend/package.json

{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "proxy": "http://127.0.0.1:8000",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "test": "jest"
  },
  "dependencies": {
    "@reduxjs/toolkit": "^2.2.3",
    "axios": "^1.6.8",
    "js-cookie": "^3.0.5",
    "js-cookies": "^1.0.4",
    "libsodium-wrappers": "^0.7.13",
    "qrcode": "^1.5.3",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-redux": "^9.1.1",
    "react-router-dom": "^6.22.3",
    "redux-thunk": "^3.1.0",
    "selenium-webdriver": "^4.19.0"
  },
  "devDependencies": {
    "@babel/plugin-transform-runtime": "^7.24.3",
    "@babel/preset-env": "^7.24.4",
    "@babel/preset-react": "^7.24.1",
    "@testing-library/jest-dom": "^6.4.2",
    "@testing-library/react": "^15.0.2",
    "@types/react": "^18.2.79",
    "@types/react-dom": "^18.2.25",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react": "^7.34.1",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.6",
    "jest": "^29.7.0",
    "vite": "^5.2.9"
  },
  "description": "This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.",
  "main": "vite.config.js",
  "keywords": [],
  "author": "",
  "license": "ISC"
}

</code_file>

<code_file>
### File: ./frontend/vite.config.js

import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  server: {
    port: 3000
  },
  plugins: [
    react()
  ],
  resolve: {
    alias: {
      // Add aliases
      '@': path.resolve(__dirname, './src'),
      // Ensure redux toolkit is correctly recognized
      '@reduxjs/toolkit': path.resolve(__dirname, 'node_modules/@reduxjs/toolkit')
    }
  },
  build: {
    rollupOptions: {
      external: [], // Define external packages if necessary
      output: {
        // Adjust chunking behavior
        manualChunks(id) {
          if (id.includes('node_modules')) {
            return id.toString().split('node_modules/')[1].split('/')[0].toString();
          }
        }
      }
    }
  },
  optimizeDeps: {
    include: ['@reduxjs/toolkit'],
  }
});

</code_file>

<code_file>
### File: ./frontend/jest.config.cjs

// jest.config.cjs
module.exports = {
  transform: {
    '^.+\\.[t|j]sx?$': ['babel-jest', { configFile: './babel.config.cjs' }],
  },
  testEnvironment: 'node',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1'
  }
};
</code_file>

<code_file>
### File: ./frontend/babel.config.cjs

// babel.config.cjs
module.exports = {
  presets: [
    ['@babel/preset-env', { targets: { node: 'current' } }],
    '@babel/preset-react'
  ],
  plugins: [
    '@babel/plugin-transform-runtime'
  ]
};
</code_file>

<code_file>
### File: ./frontend/src/App.jsx

// ./frontend/src/App.jsx

import React from 'react';
import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';
import LandingPage from './pages/LandingPage';
import NotFoundPage from './pages/NotFoundPage';
import './styles/App.css'; // Global Styles

// This serves as the router for our different pages.
function App() {
  return (
      <Routes>
        <Route path="/" element={<LandingPage />} />
        <Route path="*" element={<NotFoundPage />} />
      </Routes>
  );
}

export default App;

</code_file>

<code_file>
### File: ./frontend/src/main.jsx

// ./frontend/src/main.jsx
import React, { useEffect, useState } from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './index.css';
import { Provider } from 'react-redux';
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <BrowserRouter>
      <App />
  </BrowserRouter>
);

</code_file>

<code_file>
### File: ./frontend/src/components/Layout.jsx

// ./frontend/src/components/Layout.jsx

import React from 'react';
import { Link } from 'react-router-dom';

function Layout({ children }) {
    return (
        <div>
            <nav className="navbar navbar-expand-lg navbar-light bg-light">
                <div className="container">
                    <Link className="navbar-brand" to="/">Encrypted File Transfer</Link>
                </div>
            </nav>
            {children}
        </div>
    );
}

export default Layout;

</code_file>

<code_file>
### File: ./frontend/src/components/handleUpload.jsx

// ./frontend/src/components/handleUpload.jsx

import Cookies from 'js-cookie';
//import { handleCryptoOperations } from '../pages/LandingPage';

const handleUpload = async (event) => {
  event.preventDefault();

  try {
    // Send the POST request to the backend
    const response = await fetch('https://api.test-server-0.click/api/file_process/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': Cookies.get('csrftoken'),
      },
    });

    const data = await response.json();
    console.log('Response from backend:', data); // Log the response

    // You can further process the data here (e.g., display it to the user)

  } catch (error) {
    console.error('Error:', error);
    // Handle errors appropriately (e.g., display an error message)
  }
};

// const handleUpload = async (event) => {
//   event.preventDefault();

//   try {
//     // Send the initial "create" request to the backend
//     const createResponse = await fetch('https://api.test-server-0.click/api/file_process/', {
//       method: 'POST',
//       headers: {
//         'Content-Type': 'application/json',
//         'X-CSRFToken': Cookies.get('csrftoken'),
//       },
//     });

//     const createData = await createResponse.json();
//     const { id, subId } = createData;

//     // Get the file and file name from the input
//     const fileInput = event.target.elements.file;
//     const file = fileInput.files[0];
//     const fileName = file.name;

//     // Encrypt the file and file name using the provided encryption routine
//     const { encryptedFile, encryptedFileName } = await handleCryptoOperations(subId, fileName, file);

//     // Make a PUT request to the signed URL to upload the encrypted file
//     const uploadResponse = await fetch(createData.signedUrl, {
//       method: 'PUT',
//       body: encryptedFile,
//     });

//     if (uploadResponse.ok) {
//       // Inform the backend about the file upload completion
//       await fetch(`https://api.test-server-0.click/api/${id}/${subId}/upload-complete`, {
//         method: 'PUT',
//         headers: {
//           'Content-Type': 'application/json',
//           'X-CSRFToken': Cookies.get('csrftoken'),
//         },
//         body: JSON.stringify({
//           fileName: encryptedFileName,
//           fileSize: encryptedFile.size,
//         }),
//       });

//       alert('File uploaded successfully!');
//     } else {
//       alert('Failed to upload file.');
//     }
//   } catch (error) {
//     console.error('Upload error:', error);
//     alert('An error occurred while uploading the file.');
//   }
// };

const handleFileChange = async (event, fileLimits) => {
  event.preventDefault();
  const file = event.target.files[0];

  if (file) {
    const fileSize = file.size;

    if (fileLimits && fileSize > fileLimits.totalFileSizeMb * 1024 * 1024) {
      event.target.value = '';
      alert(`File size exceeds the limit of ${fileLimits.totalFileSizeMb} MB.`);
      return;
    }
  }
};

export { handleFileChange, handleUpload };
</code_file>

<code_file>
### File: ./frontend/src/components/LoadingAnimation.jsx

// ./frontend/src/components/animations.jsx
import '../styles/LoadingAnimation.css';

const LoadingAnimation = () => {
  return (
    <div className="dot-bricks" aria-label="Loading..."></div>
  );
};

export default LoadingAnimation;
</code_file>

<code_file>
### File: ./frontend/src/pages/LandingPage.jsx

// ./frontend/src/pages/LandingPage.jsx

import React, { useEffect, useState } from 'react';
import Layout from '../components/Layout';
import { handleFileChange, handleUpload } from '../components/handleUpload'
import LoadingAnimation from '../components/LoadingAnimation'
import Cookies from 'js-cookie';
import {
    ready as sodiumReady, from_string, to_hex, to_string, crypto_aead_xchacha20poly1305_ietf_encrypt,
    crypto_aead_xchacha20poly1305_ietf_keygen, crypto_aead_xchacha20poly1305_ietf_decrypt
} from 'libsodium-wrappers';


function LandingPage() {
    // const handleUpload = async (event) => {

    //     event.preventDefault();
    //     const formData = new FormData(event.currentTarget);
    //     formData.append('file', event.currentTarget.file.files[0]);
    //     try {
    //         const response = await fetch('https://api.test-server-0.click/api/file_process/',
    //             {
    //                 method: 'POST',
    //                 body: formData,
    //                 headers:

    //                 {
    //                     'X-CSRFToken': Cookies.get('csrftoken'), // Always pass the CSRF token, Derek! (-_-")
    //                 },
    //             }
    //         );

    //         const data = await response.json();

    //         if (data.url) {
    //             alert(`File uploaded! Download link: ${data.url}`);

    //             // Save the URL in local storage
    //             localStorage.setItem('fileDownloadLink', JSON.stringify({ url: data.url, timestamp: new Date().getTime() }));
    //         } else {
    //             alert('Failed to upload file.');
    //         }
    //     } catch (error) {
    //         console.error('Upload error:', error);
    //         alert('An error occurred while uploading the file.');
    //     }
    // };


    // Sort of serves as an on/off switch for our loading.
    // Starts in the Off State
    const [loading, setLoading] = useState(false);
    const [fileLimits, setFileLimits] = useState(null);

    useEffect(() => {
        async function fetchFileLimits() {
            setLoading(true); // Start loading
            try {
                const response = await fetch('https://api.test-server-0.click/api/file_limits/', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': Cookies.get('csrfToken'),
                    },
                });
                const data = await response.json();
                console.log('List of file limits:', data);
                setFileLimits(data);
            } catch (error) {
                console.error('Error returning file limits:', error);
            } finally {
                setLoading(false); // Stop loading regardless of success or failure
            }
        }

        fetchFileLimits();
    }, []);

    useEffect(() => {
        async function handleCryptoOperations(subId, fileName, file) {
            await sodiumReady;

            function shuffleString(str) {
                let arr = str.split("");
                for (let i = arr.length - 1; i > 0; i--) {
                    let j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]]; // Swap elements
                }
                return arr.join("");
            }

            function generateIV(baseString, index) {
                const encodedString = Array.from(baseString).map(char =>
                    String.fromCharCode((char.charCodeAt(0) - 32) % 95 + 32)
                ).join('');
                const shuffled = shuffleString(encodedString);
                const permutation = shuffled.substring(0, 20);
                const indexStr = index.toString().padStart(4, '0');
                let resultString = permutation + indexStr;

                for (let i = 0; i < 3; i++) {
                    if (resultString[20 + i] === '0') {
                        resultString = resultString.substring(0, 20 + i) +
                            shuffled.charAt(Math.floor(Math.random() * 20)) +
                            resultString.substring(20 + i + 1);
                    }
                }
                return from_string(resultString); // Convert to bytes for IV
            }

            const fileNameIndex = 0;
            const fileDataIndex = 1;

            const key = crypto_aead_xchacha20poly1305_ietf_keygen();

            const fileNameIV = generateIV(subId, fileNameIndex);
            const encryptedFileName = crypto_aead_xchacha20poly1305_ietf_encrypt(
                fileName, null, null, fileNameIV, key
            );

            const fileDataIV = generateIV(subId, fileDataIndex);
            const fileData = await file.arrayBuffer();
            const encryptedFileData = crypto_aead_xchacha20poly1305_ietf_encrypt(
                fileData, null, null, fileDataIV, key
            );

            return {
                encryptedFileName: to_hex(encryptedFileName),
                encryptedFile: new Blob([encryptedFileData], { type: file.type }),
                key: to_hex(key),
            };
        }
    }, []);

    useEffect(() => {
        async function checkS3Connection() {
            const csrfToken = Cookies.get('csrfToken');
            try {
                const response = await fetch('https://api.test-server-0.click/api/test_s3/', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken,
                    },
                });
                const data = await response.json();
                console.log('S3 Connection Test:', data);
            } catch (error) {
                console.error('Error testing S3 connection:', error);
            }
        }
        checkS3Connection();
    }, []);

    // // Check and display the URL on page load if it's still valid
    // useEffect(() => {
    //     const fileLinkData = JSON.parse(localStorage.getItem('fileDownloadLink'));
    //     if (fileLinkData && new Date().getTime() - fileLinkData.timestamp < 86400000) { // 24 hours check
    //         alert(`Your download link is still available: ${fileLinkData.url}`);
    //     }
    // }, []);

    return (
        <Layout>
            <div className="container mt-12">
                {loading ? <LoadingAnimation /> : (
                    <div className="row justify-content-center">
                        <div className="col g-0">
                            <div className="text-center mt-5 bg-secondary ps-5 pe-5 pb-5 pt-3 rounded shadow">
                                <h1>Welcome to Secure File Transfer</h1>
                                <p>This application allows you to securely send files to other users. Upload a file to create a secure QR code.</p>
                                <form onSubmit={handleUpload} className="mt-4">
                                    <input type="file" name="file" required onChange={(event) => handleFileChange(event, fileLimits)} />
                                    <button type="submit" className="btn btn-success">Upload File</button>
                                </form>
                            </div>
                        </div>
                    </div>
                )}
            </div>
        </Layout>
    );
}
export default LandingPage;
</code_file>

<code_file>
### File: ./frontend/src/pages/NotFoundPage.jsx

import React from 'react';
import Layout from '../components/Layout';

function NotFoundPage() {
  return (
    <Layout>
      <div className="container">
        <div className="row justify-content-center">
          <div className="col-12 text-center">
            <h1>404 Not Found</h1>
            <p>The page you are looking for does not exist.</p>
          </div>
        </div>
      </div>
    </Layout>
  );
}

export default NotFoundPage;

</code_file>

